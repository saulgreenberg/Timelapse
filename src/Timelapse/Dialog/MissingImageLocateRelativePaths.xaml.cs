using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using Timelapse.Constant;
using Timelapse.Database;
using Timelapse.Enums;
using Timelapse.Images;
using Timelapse.Util;

namespace Timelapse.Dialog
{
    /// <summary>
    /// Interaction logic for FindMissingImageFolder.xaml
    /// </summary>
    public partial class MissingImageLocateRelativePaths
    {
        #region Public Properties
        public Tuple<string, string> LocatedMissingFile
        {
            get
            {
                foreach (Tuple<string, string, bool> tuple in observableCollection)
                {
                    if (tuple.Item3)
                    {
                        return new(Path.GetDirectoryName(tuple.Item1), Path.GetFileName(tuple.Item1));
                    }
                }
                // Should never happen as at least one 'Use' checkmark is checked
                return new(string.Empty, string.Empty);
            }
        }
        #endregion

        #region Private Variables
        private readonly string RootPathToImages;
        private ObservableCollection<Tuple<string, string, bool>> observableCollection; // A tuple defining the contents of the datagrid
        private IList<DataGridCellInfo> selectedRowTuple; // Will contain the tuple of the row corresponding to the selected cell
        #endregion

        #region Constructor, Loaded and AutoGeneratedColumns
        public MissingImageLocateRelativePaths(Window owner, FileDatabase fileDatabase, string relativePath, string fileName, Dictionary<string, List<string>> candidates)
        {

            // Keeps the tooltip open until the user moves off the data row
            //ToolTipService.ShowDurationProperty.OverrideMetadata(typeof(DependencyObject), new FrameworkPropertyMetadata(Int32.MaxValue));

            InitializeComponent();
            FormattedDialogHelper.SetupStaticReferenceResolver(Message);
            if (fileDatabase == null || candidates == null || candidates.Count == 0)
            {
                // Nothing to do. Abort
                DialogResult = false;
                return;
            }

            this.Owner = owner;
            this.RootPathToImages = fileDatabase.RootPathToImages;

            // Show the file name and its full relative path in the UI
            RunImageName.Text = fileName;
            RunRelativePath.Text = relativePath;

            // Create a collection comprising: relative path to the found image, number of other missing images found in that relative path, and whether or not that relative path should be used.
            // Then display it by binding it to the data grid 
            observableCollection = [];
            int i = 0;
            foreach (KeyValuePair<string, List<string>> candidate in candidates)
            {
                observableCollection.Add(new(Path.Combine(candidate.Key, fileName), candidate.Value.Count.ToString(), i++ == 0));
            }
            DataGrid.ItemsSource = observableCollection;
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            this.Message.BuildContentFromProperties();
            Dialogs.TryPositionAndFitDialogIntoWindow(this);
            // Get rid of those ugly empty cell headers atop the Locate/View columns
            DataGrid.Columns[0].HeaderStyle = CreateEmptyHeaderStyle();

        }

        // Create the datagrid column headers
        private void MatchDataGrid_AutoGeneratedColumns(object sender, EventArgs e)
        {
            DataGrid.Columns[1].Header = "Possible new location";
            DataGrid.Columns[1].Width = new(1, DataGridLengthUnitType.Star);
            DataGrid.Columns[2].Header = "# Matching files";

            DataGrid.Columns[2].Width = new(1, DataGridLengthUnitType.Auto);
            DataGrid.Columns[3].Header = "Use?";
            DataGrid.Columns[3].Width = new(2, DataGridLengthUnitType.Auto);
        }
        #endregion

        #region Button callbacks
        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
        }

        private void OkButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = true;
        }
        #endregion

        #region Datagridrow callbacks to display file image in thumbnails
        // When the user enters a listbox item, show the image
        private void Row_MouseEnter(object sender, MouseEventArgs e)
        {
            if (!(sender is DataGridRow dgr))
            {
                return;
            }
            if (dgr.Item == null)
            {
                return;
            }

            Tuple<string, string, bool> tuple = (Tuple<string, string, bool>)dgr.Item;
            string path = Path.Combine(this.RootPathToImages, tuple.Item1);
            Image image = new()
            {
                Source = FilesFolders.GetFileTypeByItsExtension(path) == FileExtensionEnum.IsImage
                ? BitmapUtilities.GetBitmapFromImageFile(path, ImageValues.PreviewWidth480, ImageDisplayIntentEnum.Ephemeral, ImageDimensionEnum.UseWidth, out _)
                : BitmapUtilities.GetBitmapFromVideoFile(path, ImageValues.PreviewWidth480, ImageDisplayIntentEnum.Ephemeral,  ImageDimensionEnum.UseWidth, null, out _),
                HorizontalAlignment = HorizontalAlignment.Left
            };
            dgr.ToolTip = image;
        }

        // When the user leaves the row, remove the image
        private void Row_MouseLeave(object sender, MouseEventArgs e)
        {
            if (!(sender is DataGridRow dgr))
            {
                return;
            }
            dgr.ToolTip = null;
        }
        #endregion

        #region DataGrid callbacks
        // Remember the tuple of the selected row
        private void MatchDataGrid_SelectedCellsChanged(object sender, SelectedCellsChangedEventArgs e)
        {
            selectedRowTuple = e.AddedCells;
        }

        // Determine if the user clicked the View or Checkmark cell, and take the appropriate action
        private void MatchDataGrid_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            if (selectedRowTuple == null || selectedRowTuple.Count == 0 || selectedRowTuple[0].Item == null)
            {
                return;
            }
            int selectedColumn = selectedRowTuple[0].Column.DisplayIndex;
            string possibleFolderLocation = Path.GetDirectoryName(GetPossibleLocationFromSelection()) ?? string.Empty;
            switch (selectedColumn)
            {
                case 0:
                    // Show the folder in the file explorer
                    ProcessExecution.TryProcessStartUsingFileExplorerOnFolder(Path.Combine(this.RootPathToImages, possibleFolderLocation));
                    break;
                case 3:
                    // Use checkmark has been selected. 
                    // We need to update the datagrid with the new value. 
                    // To keep it simple,  just rebuild the observable collection and rebind it
                    Tuple<string, string, bool>  rowValues = (Tuple<string, string, bool>)selectedRowTuple[0].Item;

                    ObservableCollection<Tuple<string, string, bool>>  obsCollection = [];
                    foreach (Tuple<string, string, bool> row in observableCollection)
                    {
                       
                        obsCollection.Add(!Equals(row, rowValues)
                            // To make it work as a radio butotn, toggle all other rows to be what the selected row is not
                            ? new(row.Item1, row.Item2, rowValues.Item3)
                            // Toggle the selected row
                            : new Tuple<string, string, bool>(rowValues.Item1, rowValues.Item2, !rowValues.Item3));
                    }
                    observableCollection = obsCollection;
                    DataGrid.ItemsSource = observableCollection;
                    break;
                default:
                    return;
            }
        }
        #endregion

        #region Helper methods
        private string GetPossibleLocationFromSelection()
        {
            Tuple<string, string, bool> tuple = (Tuple<string, string, bool>)selectedRowTuple[0].Item;
            return (tuple != null)
                ? tuple.Item1
                : string.Empty;
        }
        #endregion

        #region Styles
        // A ColumnHeader style that appears (more or less) empty
        private static Style CreateEmptyHeaderStyle()
        {
            // Its way more compact to use the xaml approach rather than to declare styles, setters, etc.
            // But we have to ensure the expression is well formed.
            string xaml = "<Style xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" " +
                "TargetType=\"DataGridColumnHeader\">" +
                "<Setter Property=\"Background\" Value=\"White\"/>" +
                 "<Setter Property=\"BorderThickness\" Value=\"0, 0, 0, 1\"/>" +
                "</Style>";
            return XamlReader.Parse(xaml) as Style;
        }
        #endregion
    }
}

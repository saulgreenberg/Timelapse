using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using Timelapse.Constant;
using Timelapse.Controls;
using Timelapse.Database;
using Timelapse.DataStructures;
using Timelapse.DataTables;
using Timelapse.Enums;
using Timelapse.Util;

namespace Timelapse.Dialog
{
    /// <summary>
    /// Interaction logic for TestPopulate.xaml
    /// </summary>
    public partial class PopulateFieldsWithMetadata
    {
        #region Private variables
        // Passed in parameters
        private readonly string FilePath;
        private readonly FileDatabase FileDatabase;

        // Tracks whether any changes to the data or database are made
        private bool isAnyDataUpdated;

        // Track the checkbox for clearing values if no matching metadata is found
        private bool clearIfNoMetadata;
        private readonly Dictionary<string,string> DataLabelControlTypeDict = new();
        private readonly bool useDateMetadataOnly;
        #endregion

        #region Initialization
        public PopulateFieldsWithMetadata(Window owner, FileDatabase fileDatabase, string filePath, bool useDateMetadataOnly) : base(owner)
        {
            InitializeComponent();
            FilePath = filePath;
            FileDatabase = fileDatabase;
            this.useDateMetadataOnly = useDateMetadataOnly;
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            this.PopulateAllMessage.BuildContentFromProperties();
            this.DatesOnlyMessage.BuildContentFromProperties();
            // Set up a progress handler that will update the progress bar
            InitalizeProgressHandler(BusyCancelIndicator);
            MetadataGrid.viewModel.FilePath = FilePath;

            if (useDateMetadataOnly)
            {
                // The default is to use the Populate Fields ... help and Window title, and to include the Clear checkbox
                // If we are using it only to select date metadata, we need to switch to that
                PopulateAllMessage.Visibility = Visibility.Collapsed;
                DatesOnlyMessage.Visibility = Visibility.Visible;
                Title = "Populate dates and times from a metadata field";
                ClearIfNoMetadata.Visibility = Visibility.Collapsed;
            }

            // Set the grid to its all metadata form or its date only form  
            MetadataGrid.UseDateMetadataOnly = useDateMetadataOnly;

            // Construct a dictionary of the available note fields as labels|datalabels
            // and a list of only the note field labels which will be used to populate the ComboBoxes in the datagrid
            Dictionary<string, string> collectLabels = new Dictionary<string, string>();
            foreach (ControlRow control in FileDatabase.Controls)
            {
                if (useDateMetadataOnly &&
                    (control.Type == DatabaseColumn.DateTime || control.Type == Control.DateTime_ || 
                     control.Type == Control.Date_ || control.Type == Control.Time_))
                {
                    // Only include the DateTime control
                    collectLabels.Add(control.DataLabel, control.Label);
                    DataLabelControlTypeDict.Add(control.DataLabel, control.Type);
                }
                else if (false == useDateMetadataOnly &&
                         IsCondition.IsControlType_Note_MultiLine(control.Type))
                {
                    // Include all Note or Multiline controls
                    collectLabels.Add(control.DataLabel, control.Label);
                }
            }
            // Setting DictDataLabel_Label will result in desired side effects in the FileMetadataGrid user control
            MetadataGrid.DictDataLabel_Label = collectLabels;
            MetadataGrid.SelectedMetadata.CollectionChanged += SelectedMetadata_CollectionChanged;
        }

        // This datagrid will indicate, for the selected metadata, the metadata values assigned to the selected field
        private void FeedbackDatagrid_AutoGeneratedColumns(object sender, EventArgs e)
        {
            FeedbackGrid.Columns[0].Header = "File Name";
            FeedbackGrid.Columns[1].Header = "Metadata name";
            FeedbackGrid.Columns[2].Header = "Metadata Value";
        }
        #endregion

        #region Closing
        private void Window_Closing(object sender, CancelEventArgs e)
        {
            DialogResult = Token.IsCancellationRequested || isAnyDataUpdated;
        }
        #endregion

        #region Change Notifications
        private void SelectedMetadata_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            // Enable or disable the Populate button to match if any items are in the selectedMetadataList 
            StartDoneButton.IsEnabled = MetadataGrid.SelectedMetadata is { Count: > 0 };
        }
        #endregion

        #region Button callbacks
        private async void Start_Click(object sender, RoutedEventArgs e)
        {
            // Update the UI to show the feedback datagrid, 
            PopulatingMessage.Text = "Populating metadata";
            CancelButton.IsEnabled = false;
            CancelButton.Visibility = Visibility.Hidden;
            StartDoneButton.Content = "_Done";
            StartDoneButton.Click -= Start_Click;
            StartDoneButton.Click += Done_Click;
            StartDoneButton.IsEnabled = false;
            BusyCancelIndicator.IsBusy = true;
            WindowCloseButtonIsEnabled(false);

            MetadataGrid.Visibility = Visibility.Collapsed;  // Hide the various panels to reveal the feedback datagrid
            ClearIfNoMetadata.Visibility = Visibility.Collapsed; // Hide the checkbox button for the same reason
            FeedbackPanel.Visibility = Visibility.Visible; // Show the feedback panel
            WindowCloseButtonIsEnabled(false); // Disable the window's close button

            // This call does all the actual populating...
            ObservableCollection<Tuple<string, string, string>> feedbackData = await PopulateAsync(MetadataGrid.MetadataToolSelected).ConfigureAwait(true);

            // Update the UI to its final state
            StartDoneButton.IsEnabled = true;
            BusyCancelIndicator.IsBusy = false;
            WindowCloseButtonIsEnabled(true);
            FeedbackGrid.ItemsSource = feedbackData;
            PopulatingMessage.Text = Token.IsCancellationRequested
                ? "Cancelled - content is unchanged."
                : "Populated metadata as follows.";
        }
        private void Done_Click(object sender, RoutedEventArgs e)
        {

            // We return true if the database was altered but also if there was a cancellation, as a cancelled operation
            // may have changed the FileTable (but not database) date entries. Returning true will reset them, as a FileSelectAndShow will be done.
            // Kinda hacky as it expects a certain behaviour of the caller, but it works.
            DialogResult = Token.IsCancellationRequested || isAnyDataUpdated;
        }
        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = Token.IsCancellationRequested || isAnyDataUpdated;
        }
        #endregion

        #region Checkbox callbacks
        // Checkbox callback sets the state as to whether the data field should be cleared or left alone if there is no metadata
        private void ClearIfNoMetadata_Checked(object sender, RoutedEventArgs e)
        {
            clearIfNoMetadata = (ClearIfNoMetadata.IsChecked == true);
        }
        #endregion

        #region Do the work: Populate the database 
        // Populate the database with the metadata for the selected note field
        private async Task<ObservableCollection<Tuple<string, string, string>>> PopulateAsync(MetadataToolEnum metadataToolSelected)
        {
            // This list will hold key / value pairs that will be bound to the datagrid feedback, 
            // which is the way to make those pairs appear in the data grid during background worker progress updates
            ObservableCollection<Tuple<string, string, string>> feedbackData = [];

            // if there are no metadata / label pairs, we are done.
            if (MetadataGrid.SelectedMetadata.Count == 0)
            {
                // Catch the case where there are no selected pairs, at least for now.
                feedbackData.Clear();
                feedbackData.Add(new Tuple<string, string, string>("Nothing was selected", "", "No changes were made"));
                return feedbackData;
            }

            return await Task.Run(() =>
            {
                // For each row in the database, get the image filename and try to extract the chosen metadata value.
                // If we can't decide if we want to leave the data field alone or to clear it depending on the state of the isClearIfNoMetadata (set via the checkbox)
                // Report progress as needed.

                // This tuple list will hold the id, key and value that we will want to update in the database
                List<ColumnTuplesWithWhere> imagesToUpdate = [];
                
                double totalImages = FileDatabase.CountAllCurrentlySelectedFiles;
                Dictionary<string, ImageMetadata> metadata = new Dictionary<string, ImageMetadata>();
                string[] tags = MetadataGrid.SelectedTags;// Only needed by ExifTool, but cheap to get
                for (int imageIndex = 0; imageIndex < totalImages; ++imageIndex)
                {
                    // Provide feedback if the operation was cancelled during the database update
                    if (Token.IsCancellationRequested)
                    {
                        feedbackData.Clear();
                        feedbackData.Add(new Tuple<string, string, string>("Cancelled", "", "No changes were made"));
                        return feedbackData;
                    }

                    ImageRow image = FileDatabase.FileTable[imageIndex];

                    if (metadataToolSelected == MetadataToolEnum.MetadataExtractor)
                    {
                        // MetadataExtractor specific code
                        metadata = ImageMetadataDictionary.LoadMetadata(image.GetFilePath(FileDatabase.RootPathToImages));
                    }
                    else // if metadataToolSelected == MetadataToolEnum.ExifTool
                    {
                        // ExifTool specific code - note that we transform results into the same dictionary structure used by the MetadataExtractor
                        // Unlike MetadataExtractor, ExifTool returns TagName instad of Directory.TagName (I think - but does that mean it would break on duplicate values?
                        metadata.Clear();
                        Dictionary<string, string> exifData = MetadataGrid.ExifToolManager.FetchExifFrom(image.GetFilePath(FileDatabase.RootPathToImages), tags);
                        foreach (string tag in tags)
                        {
                            if (exifData.TryGetValue(tag, out var value))
                            {
                                metadata.Add(tag, new ImageMetadata(string.Empty, tag, value));
                            }
                        }
                    }
                    // At this point, the metadata Key should be the tag name, rather than Directory.TagName
                    // (see ImageMetadataDiction.LoadDictionary to change it back so the key is the directory.name. I think Exif never returns the directory name, so thats ok too.

                    if (ReadyToRefresh())
                    {
                        int percentDone = Convert.ToInt32(imageIndex / totalImages * 100.0);
                        Progress.Report(new ProgressBarArguments(percentDone,
                            $"{imageIndex}/{totalImages} images. Processing {image.File}", true, false));
                        Thread.Sleep(ThrottleValues.RenderingBackoffTime);  // Allows the UI thread to update every now and then
                    }

                    foreach (KeyValuePair<string, string> kvp in MetadataGrid.SelectedMetadata)
                    {
                        string metadataTag = kvp.Key;
                        string dataLabelToUpdate = kvp.Value;
                        if (false == metadata.TryGetValue(metadataTag, out var value))
                        {
                            // This just skips this metadata as it was not found in the file's metadata
                            // However, we still need to supply feedback and (if the user has asked for that option) to clear the data field
                            if (clearIfNoMetadata)
                            {
                                List<ColumnTuple> clearField = [new ColumnTuple(dataLabelToUpdate, string.Empty)];
                                imagesToUpdate.Add(new ColumnTuplesWithWhere(clearField, image.ID));
                                feedbackData.Add(new Tuple<string, string, string>(image.File, metadataTag, "No metadata found - data field cleared"));
                            }
                            else
                            {
                                feedbackData.Add(new Tuple<string, string, string>(image.File, metadataTag, "No metadata found - data field unchanged"));
                            }
                            continue;
                        }
                        string metadataValue = value.Value;
                        ColumnTuplesWithWhere imageUpdate;
                        if (useDateMetadataOnly)
                        {
                            string dateTimeStringToUse = string.Empty;
                            if (DateTimeHandler.TryParseMetadataDateTaken(metadataValue, out DateTime metadataDateTime))
                            {
                                if (dataLabelToUpdate == DatabaseColumn.DateTime)
                                {
                                    // NO! USE IMAGE ROW
                                    dateTimeStringToUse = DateTimeHandler.ToStringDatabaseDateTime(metadataDateTime);
                                    image.SetDateTime(metadataDateTime);
                                    imageUpdate = image.GetDateTimeColumnTuples();
                                    feedbackData.Add(new Tuple<string, string, string>(image.File, metadataTag, dateTimeStringToUse));
                                }
                                else
                                {
                                    string controlType = DataLabelControlTypeDict[dataLabelToUpdate];
                                    if (controlType == Control.DateTime_)
                                    {
                                        dateTimeStringToUse = DateTimeHandler.ToStringDatabaseDateTime(metadataDateTime);
                                    }
                                    else if (controlType == Control.Date_)
                                    {
                                        dateTimeStringToUse = DateTimeHandler.ToStringDatabaseDate(metadataDateTime);
                                    }
                                    else if (controlType == Control.Time_)
                                    {
                                        dateTimeStringToUse = DateTimeHandler.ToStringTime(metadataDateTime);
                                    }
                                    if (false == string.IsNullOrEmpty(dateTimeStringToUse) )
                                    {
                                        imageUpdate = new ColumnTuplesWithWhere([new ColumnTuple(dataLabelToUpdate, dateTimeStringToUse)], image.ID);
                                        feedbackData.Add(new Tuple<string, string, string>(image.File, metadataTag, metadataValue));
                                    }
                                    else
                                    {
                                        feedbackData.Add(new Tuple<string, string, string>(image.File, metadataTag,
                                            $"Data field unchanged - '{metadataValue}' is not a valid date/time."));
                                         continue;
                                    }
                                }
                            }
                            else
                            {
                                feedbackData.Add(new Tuple<string, string, string>(image.File, metadataTag,
                                    $"Data field unchanged - '{metadataValue}' is not a valid date/time."));
                                continue;
                            }
                        }
                        else
                        {
                            imageUpdate = new ColumnTuplesWithWhere([new ColumnTuple(dataLabelToUpdate, metadataValue)], image.ID);
                            feedbackData.Add(new Tuple<string, string, string>(image.File, metadataTag, metadataValue));
                        }
                        imagesToUpdate.Add(imageUpdate);
                    }
                }
                isAnyDataUpdated = true;
                Progress.Report(new ProgressBarArguments(100,
                    $"Writing metadata for {totalImages} files. Please wait...", false, true));
                Thread.Sleep(ThrottleValues.RenderingBackoffTime);  // Allows the UI thread to update every now and then
                FileDatabase.UpdateFiles(imagesToUpdate);
                return feedbackData;
            }, Token).ConfigureAwait(true);
        }
        #endregion
    }
}
